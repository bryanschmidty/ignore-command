#!/usr/bin/env bash
set -euo pipefail

cd "$(git rev-parse --show-toplevel 2>/dev/null)" || {
  echo "Not inside a git repository."
  exit 1
}

EXCLUDE_FILE=".git/info/exclude"
UPSTREAM_REF=""
SKIP_REMOTE_CHANGED=()
EXCLUDE_MISSING=()

init_colors() {
  if [ -t 1 ] && [ -z "${NO_COLOR:-}" ]; then
    C_RESET="\033[0m"
    C_BOLD="\033[1m"
    C_DIM="\033[2m"
    C_RED="\033[31m"
    C_GREEN="\033[32m"
    C_YELLOW="\033[33m"
    C_BLUE="\033[34m"
    C_MAGENTA="\033[35m"
    C_CYAN="\033[36m"
  else
    C_RESET=""
    C_BOLD=""
    C_DIM=""
    C_RED=""
    C_GREEN=""
    C_YELLOW=""
    C_BLUE=""
    C_MAGENTA=""
    C_CYAN=""
  fi
}

print_error() {
  printf "%b\n" "${C_RED}$*${C_RESET}"
}

print_success() {
  printf "%b\n" "${C_GREEN}$*${C_RESET}"
}

print_info() {
  printf "%b\n" "${C_BLUE}$*${C_RESET}"
}

index_to_key() {
  local n="$1"
  if [ "$n" -le 9 ]; then
    printf "%d" "$n"
    return
  fi

  local x=$((n - 10))
  local key=""
  local rem
  while true; do
    rem=$((x % 26))
    key="$(printf "\\$(printf '%03o' $((97 + rem)))")${key}"
    x=$((x / 26 - 1))
    if [ "$x" -lt 0 ]; then
      break
    fi
  done
  printf "%s" "$key"
}

choose_item_to_remove() {
  local title="$1"
  local empty_message="$2"
  shift 2

  local items=()
  local p
  for p in "$@"; do
    if [ -n "$p" ]; then
      items+=("$p")
    fi
  done

  if [ "${#items[@]}" -eq 0 ]; then
    printf "%b\n" "${C_YELLOW}${empty_message}${C_RESET}"
    return 1
  fi

  echo
  printf "%b\n" "${C_BOLD}${C_MAGENTA}== ${title} ==${C_RESET}"
  local i key
  for i in "${!items[@]}"; do
    key="$(index_to_key $((i + 1)))"
    printf "  %b%s)%b %s\n" "$C_CYAN" "$key" "$C_RESET" "${items[$i]}"
  done

  while true; do
    printf "%b" "${C_BLUE}Remove which item? (key or q): ${C_RESET}" >&2
    read -r selection
    selection="$(printf "%s" "$selection" | tr '[:upper:]' '[:lower:]')"

    if [ "$selection" = "q" ]; then
      return 1
    fi

    for i in "${!items[@]}"; do
      key="$(index_to_key $((i + 1)))"
      if [ "$selection" = "$key" ]; then
        SELECTED_ITEM="${items[$i]}"
        return 0
      fi
    done

    print_error "Invalid selection: $selection"
  done
}

get_flagged() {
  local flag="$1" # h or S
  git ls-files -v | awk -v f="$flag" '$1==f {print $2}'
}

show_section() {
  local title="$1"
  local empty_message="$2"
  shift
  shift
  echo
  printf "%b\n" "${C_BOLD}${C_MAGENTA}== ${title} ==${C_RESET}"
  local items=()
  local p
  for p in "$@"; do
    if [ -n "$p" ]; then
      items+=("$p")
    fi
  done
  if [ "${#items[@]}" -eq 0 ]; then
    printf "%b\n" "${C_YELLOW}${empty_message}${C_RESET}"
    return
  fi
  local i=1
  for p in "${items[@]}"; do
    printf "%b\n" "${C_CYAN}$(printf "%2d" "$i"))${C_RESET} $p"
    i=$((i+1))
  done
}

has_remote_changes() {
  local upstream_ref="$1"
  local p="$2"
  if git diff --quiet "HEAD..$upstream_ref" -- "$p"; then
    return 1
  fi
  return 0
}

get_upstream_ref() {
  git rev-parse --abbrev-ref --symbolic-full-name '@{upstream}' 2>/dev/null || true
}

path_in_list() {
  local needle="$1"
  shift
  local p
  for p in "$@"; do
    if [ "$p" = "$needle" ]; then
      return 0
    fi
  done
  return 1
}

collect_remote_changed_skip_paths() {
  local upstream_ref="$1"
  shift
  local p
  for p in "$@"; do
    if [ -n "$p" ] && has_remote_changes "$upstream_ref" "$p"; then
      printf "%s\n" "$p"
    fi
  done
}

is_exclude_entry_present() {
  local entry="$1"
  local normalized="$entry"

  # .git/info/exclude patterns are repo-root relative when prefixed with /
  if [[ "$normalized" == /* ]]; then
    normalized="${normalized#/}"
  fi

  # Fast path for plain paths without glob chars.
  if [[ "$normalized" != *"*"* && "$normalized" != *"?"* && "$normalized" != *"["* ]]; then
    [ -e "$normalized" ] && return 0
    return 1
  fi

  # For glob patterns (including **), check if any current path matches.
  local had_dotglob had_globstar had_nullglob
  had_dotglob="$(shopt -p dotglob || true)"
  had_globstar="$(shopt -p globstar || true)"
  had_nullglob="$(shopt -p nullglob || true)"
  shopt -s dotglob globstar nullglob

  local matches=()
  mapfile -t matches < <(compgen -G "$normalized" || true)

  eval "$had_dotglob" || true
  eval "$had_globstar" || true
  eval "$had_nullglob" || true

  [ "${#matches[@]}" -gt 0 ] && return 0
  return 1
}

collect_missing_exclude_entries() {
  local entry
  for entry in "$@"; do
    if [ -n "$entry" ] && ! is_exclude_entry_present "$entry"; then
      printf "%s\n" "$entry"
    fi
  done
}

show_exclude_section() {
  local title="$1"
  local empty_message="$2"
  shift
  shift
  echo
  printf "%b\n" "${C_BOLD}${C_MAGENTA}== ${title} ==${C_RESET}"

  local items=()
  local p
  for p in "$@"; do
    if [ -n "$p" ]; then
      items+=("$p")
    fi
  done

  if [ "${#items[@]}" -eq 0 ]; then
    printf "%b\n" "${C_YELLOW}${empty_message}${C_RESET}"
    return
  fi

  local i=1
  local marker any_deleted=0
  for p in "${items[@]}"; do
    marker=" "
    if path_in_list "$p" "${EXCLUDE_MISSING[@]:-}"; then
      marker="${C_RED}D${C_RESET}"
      any_deleted=1
    fi
    printf "%b %b\n" "${marker}" "${C_CYAN}$(printf "%2d" "$i"))${C_RESET} $p"
    i=$((i+1))
  done

  if [ "$any_deleted" -eq 1 ]; then
    printf "%b\n" "${C_RED}Any entries marked with \"D\" no longer match existing files and can be removed from $EXCLUDE_FILE.${C_RESET}"
  fi
}

show_skip_section() {
  local title="$1"
  local empty_message="$2"
  shift
  shift
  echo
  printf "%b\n" "${C_BOLD}${C_MAGENTA}== ${title} ==${C_RESET}"

  local items=()
  local p
  for p in "$@"; do
    if [ -n "$p" ]; then
      items+=("$p")
    fi
  done

  if [ "${#items[@]}" -eq 0 ]; then
    printf "%b\n" "${C_YELLOW}${empty_message}${C_RESET}"
    return
  fi

  local i=1
  local marker any_marked=0
  for p in "${items[@]}"; do
    marker=" "
    if path_in_list "$p" "${SKIP_REMOTE_CHANGED[@]:-}"; then
      marker="${C_YELLOW}M${C_RESET}"
      any_marked=1
    fi
    printf "%b %b\n" "${marker}" "${C_CYAN}$(printf "%2d" "$i"))${C_RESET} $p"
    i=$((i+1))
  done

  if [ "$any_marked" -eq 1 ]; then
    printf "%b\n" "${C_YELLOW}Any files marked with \"M\" have been updated on remote (${UPSTREAM_REF}).${C_RESET}"
  elif [ -z "$UPSTREAM_REF" ]; then
    printf "%b\n" "${C_YELLOW}No upstream branch is configured; cannot check remote updates.${C_RESET}"
  fi
}

read_exclude_lines() {
  if [ -f "$EXCLUDE_FILE" ]; then
    awk '
      NR <= 200 &&
      $0 !~ /^[[:space:]]*#/ &&
      $0 !~ /^[[:space:]]*$/ { print }
    ' "$EXCLUDE_FILE"
  fi
}

is_tracked() {
  git ls-files --error-unmatch -- "$1" >/dev/null 2>&1
}

add_assume_unchanged() {
  local p="$1"
  if ! is_tracked "$p"; then
    print_error "Cannot set assume-unchanged: file is not tracked: $p"
    return 1
  fi
  git update-index --assume-unchanged -- "$p"
}

add_skip_worktree() {
  local p="$1"
  if ! is_tracked "$p"; then
    print_error "Cannot set skip-worktree: file is not tracked: $p"
    return 1
  fi
  git update-index --skip-worktree -- "$p"
}

add_exclude() {
  local p="$1"
  mkdir -p "$(dirname "$EXCLUDE_FILE")"
  touch "$EXCLUDE_FILE"

  if grep -Fxq "$p" "$EXCLUDE_FILE"; then
    printf "%b\n" "${C_YELLOW}Already in $EXCLUDE_FILE: $p${C_RESET}"
    return 0
  fi

  echo "$p" >> "$EXCLUDE_FILE"
}

prompt_path() {
  local p=""
  while true; do
    printf "%b" "${C_BLUE}Path (relative to repo root): ${C_RESET}" >&2
    read -r p
    p="${p#"./"}"
    if [ -z "$p" ]; then
      printf "%b\n" "${C_YELLOW}Please enter a path.${C_RESET}" >&2
      continue
    fi
    echo "$p"
    return 0
  done
}

refresh_display() {
  mapfile -t ASSUME < <(get_flagged "h" || true)
  mapfile -t SKIP < <(get_flagged "S" || true)
  mapfile -t EXCLUDE < <(read_exclude_lines || true)
  UPSTREAM_REF="$(get_upstream_ref)"
  SKIP_REMOTE_CHANGED=()
  if [ -n "$UPSTREAM_REF" ] && [ "${#SKIP[@]}" -gt 0 ]; then
    mapfile -t SKIP_REMOTE_CHANGED < <(collect_remote_changed_skip_paths "$UPSTREAM_REF" "${SKIP[@]}")
  fi
  EXCLUDE_MISSING=()
  if [ "${#EXCLUDE[@]}" -gt 0 ]; then
    mapfile -t EXCLUDE_MISSING < <(collect_missing_exclude_entries "${EXCLUDE[@]}")
  fi

  show_section "assume-unchanged (h)" "[No files added]" "${ASSUME[@]:-}"
  show_skip_section "skip-worktree (S)" "[No files added]" "${SKIP[@]:-}"
  show_exclude_section ".git/info/exclude" "[No paths added]" "${EXCLUDE[@]:-}"
  echo
}

menu() {
  printf "%b\n" "${C_BOLD}Choose an action:${C_RESET}"
  printf "  %b1)%b Add path to assume-unchanged\n" "$C_CYAN" "$C_RESET"
  printf "  %b2)%b Add path to skip-worktree\n" "$C_CYAN" "$C_RESET"
  printf "  %b3)%b Add path to .git/info/exclude\n" "$C_CYAN" "$C_RESET"
  printf "  %b4)%b Remove path from assume-unchanged\n" "$C_CYAN" "$C_RESET"
  printf "  %b5)%b Remove path from skip-worktree\n" "$C_CYAN" "$C_RESET"
  printf "  %b6)%b Remove exact line from .git/info/exclude\n" "$C_CYAN" "$C_RESET"
  if [ "${#EXCLUDE_MISSING[@]}" -gt 0 ]; then
    printf "  %bd)%b %bRemove excluded entries that no longer exist%b\n" "$C_CYAN" "$C_RESET" "$C_RED" "$C_RESET"
  fi
  if [ "${#SKIP_REMOTE_CHANGED[@]}" -gt 0 ]; then
    printf "  %bp)%b %bPull changes to skip-worktree files%b\n" "$C_CYAN" "$C_RESET" "$C_YELLOW" "$C_RESET"
  fi
  printf "  %br)%b Refresh / show current state\n" "$C_CYAN" "$C_RESET"
  printf "  %bq)%b Quit\n" "$C_CYAN" "$C_RESET"
}

prompt_backup_choice() {
  local choice
  while true; do
    printf "%b" "${C_BLUE}Back up local versions first (*.bak + add to $EXCLUDE_FILE)? (y/n/q): ${C_RESET}" >&2
    read -r choice
    choice="$(printf "%s" "$choice" | tr '[:upper:]' '[:lower:]')"
    case "$choice" in
      y|yes)
        echo "yes"
        return 0
        ;;
      n|no)
        echo "no"
        return 0
        ;;
      q|quit)
        echo "cancel"
        return 0
        ;;
      *)
        print_error "Please choose y, n, or q."
        ;;
    esac
  done
}

remove_assume_unchanged() {
  local p="$1"
  if ! is_tracked "$p"; then
    print_error "File is not tracked: $p"
    return 1
  fi
  git update-index --no-assume-unchanged -- "$p"
}

remove_skip_worktree() {
  local p="$1"
  if ! is_tracked "$p"; then
    print_error "File is not tracked: $p"
    return 1
  fi
  git update-index --no-skip-worktree -- "$p"
}

remove_exclude_line() {
  local p="$1"
  if [ ! -f "$EXCLUDE_FILE" ]; then
    print_error "$EXCLUDE_FILE does not exist."
    return 1
  fi
  if ! grep -Fxq "$p" "$EXCLUDE_FILE"; then
    print_error "No exact matching line found in $EXCLUDE_FILE: $p"
    return 1
  fi
  local tmp
  tmp="$(mktemp)"
  grep -Fxv "$p" "$EXCLUDE_FILE" > "$tmp"
  mv "$tmp" "$EXCLUDE_FILE"
}

remove_missing_exclude_entries() {
  if [ "${#EXCLUDE_MISSING[@]}" -eq 0 ]; then
    printf "%b\n" "${C_YELLOW}No missing exclude entries to remove.${C_RESET}"
    return 0
  fi
  if [ ! -f "$EXCLUDE_FILE" ]; then
    print_error "$EXCLUDE_FILE does not exist."
    return 1
  fi

  print_info "Removing ${#EXCLUDE_MISSING[@]} stale exclude entrie(s) from $EXCLUDE_FILE..."
  local remove_tmp out_tmp
  remove_tmp="$(mktemp)"
  out_tmp="$(mktemp)"
  printf "%s\n" "${EXCLUDE_MISSING[@]}" | awk 'NF && !seen[$0]++' > "$remove_tmp"
  awk 'NR==FNR { remove[$0]=1; next } !($0 in remove)' "$remove_tmp" "$EXCLUDE_FILE" > "$out_tmp"
  mv "$out_tmp" "$EXCLUDE_FILE"
  rm -f "$remove_tmp"
  print_success "Removed stale entries from $EXCLUDE_FILE."
}

pull_skip_worktree_remote_changes() {
  if [ -z "$UPSTREAM_REF" ]; then
    print_error "No upstream branch is configured; cannot update from remote."
    return 1
  fi

  if [ "${#SKIP_REMOTE_CHANGED[@]}" -eq 0 ]; then
    printf "%b\n" "${C_YELLOW}No skip-worktree files need updates from remote.${C_RESET}"
    return 0
  fi

  local to_update=("${SKIP_REMOTE_CHANGED[@]}")
  print_info "Preparing to update ${#to_update[@]} skip-worktree file(s) from ${UPSTREAM_REF}."
  local backup_choice
  backup_choice="$(prompt_backup_choice)"
  if [ "$backup_choice" = "cancel" ]; then
    printf "%b\n" "${C_YELLOW}Canceled update operation.${C_RESET}"
    return 1
  fi

  local p backup_path
  if [ "$backup_choice" = "yes" ]; then
    print_info "Backing up local files and adding backups to $EXCLUDE_FILE..."
    for p in "${to_update[@]}"; do
      backup_path="${p}.bak"
      mkdir -p "$(dirname "$backup_path")"
      cp -p -- "$p" "$backup_path"
      add_exclude "$backup_path"
      print_success "Backed up: $p -> $backup_path"
    done
  else
    print_info "Skipping backup step."
  fi

  print_info "Fetching latest refs from remote..."
  if git fetch --quiet; then
    print_success "Fetch complete."
  else
    print_error "git fetch failed. Resolve issues and run refresh."
    return 1
  fi

  print_info "Overwriting files from ${UPSTREAM_REF} and clearing skip-worktree..."
  local failed=0
  for p in "${to_update[@]}"; do
    remove_skip_worktree "$p"
    if git restore --source "$UPSTREAM_REF" -- "$p"; then
      print_success "Updated from remote and cleared skip-worktree: $p"
    else
      print_error "Failed to update from remote: $p"
      failed=1
    fi
  done

  if [ "$failed" -eq 1 ]; then
    print_error "Some files failed to update. Run refresh and resolve as needed."
    return 1
  fi

  print_success "Finished updating skip-worktree files from remote."

  return 0
}

main() {
  init_colors
  refresh_display

  while true; do
    menu
    printf "%b" "${C_BOLD}> ${C_RESET}"
    read -r choice
    case "$choice" in
      1)
        p="$(prompt_path)"
        add_assume_unchanged "$p" && print_success "Set assume-unchanged: $p"
        ;;
      2)
        p="$(prompt_path)"
        add_skip_worktree "$p" && print_success "Set skip-worktree: $p"
        ;;
      3)
        p="$(prompt_path)"
        add_exclude "$p" && print_success "Added to $EXCLUDE_FILE: $p"
        ;;
      4)
        mapfile -t ASSUME < <(get_flagged "h" || true)
        if choose_item_to_remove "assume-unchanged (h)" "[No files added]" "${ASSUME[@]:-}"; then
          remove_assume_unchanged "$SELECTED_ITEM" && print_success "Cleared assume-unchanged: $SELECTED_ITEM"
        fi
        ;;
      5)
        mapfile -t SKIP < <(get_flagged "S" || true)
        if choose_item_to_remove "skip-worktree (S)" "[No files added]" "${SKIP[@]:-}"; then
          remove_skip_worktree "$SELECTED_ITEM" && print_success "Cleared skip-worktree: $SELECTED_ITEM"
        fi
        ;;
      6)
        mapfile -t EXCLUDE < <(read_exclude_lines || true)
        if choose_item_to_remove ".git/info/exclude" "[No paths added]" "${EXCLUDE[@]:-}"; then
          remove_exclude_line "$SELECTED_ITEM" && print_success "Removed from $EXCLUDE_FILE: $SELECTED_ITEM"
        fi
        ;;
      d|D)
        remove_missing_exclude_entries
        ;;
      p|P)
        pull_skip_worktree_remote_changes
        ;;
      r|R)
        ;;
      q|Q)
        printf "%b\n" "${C_DIM}Bye.${C_RESET}"
        exit 0
        ;;
      *)
        print_error "Unknown choice: $choice"
        ;;
    esac

    refresh_display
  done
}

main